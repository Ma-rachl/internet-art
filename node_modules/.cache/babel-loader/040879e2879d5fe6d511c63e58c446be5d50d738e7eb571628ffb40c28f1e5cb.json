{"ast":null,"code":"import * as utils from '../common/utils.js';\nimport { getOptions } from '../common/options.js';\nimport { stopMedia, playMedia } from '../media.js';\nimport { updateState } from '../stateUpdates.js';\nimport { getState, setState, state } from '../common/state.js';\nimport { lazyLoad } from '../lazyLoad/lazyLoad.js';\nimport { setPageStatus } from '../anchors/setPageStatus.js';\nimport { activateMenuAndNav } from '../menu/activateMenuAndNav.js';\nimport { $body } from '../common/cache.js';\nimport { getYmovement } from '../common/utilsFP.js';\nimport { COMPLETELY, ACTIVE } from '../common/selectors.js';\nimport { fireCallbackOncePerScroll } from '../callbacks/fireCallbacksOncePerScroll.js';\nimport { fireCallback } from '../callbacks/fireCallback.js';\nimport { EventEmitter } from '../common/eventEmitter.js';\nimport { fitToSection } from '../fitToSection.js';\nimport { events } from '../common/events.js';\nvar lastScroll = 0;\nlet g_scrollId;\nlet g_scrollId2;\nEventEmitter.on(events.onDestroy, onDestroy);\n\n//when scrolling...\nexport function scrollHandler(e) {\n  var currentSection;\n  var currentSectionElem;\n  if (state.isResizing || !getState().activeSection) {\n    return;\n  }\n  var lastSection = utils.getLast(getState().sections);\n  if (getState().isBeyondFullpage || getState().isAboutToScrollToFullPage) {\n    return;\n  }\n  if (!getOptions().autoScrolling || getOptions().scrollBar) {\n    var currentScroll = utils.getScrollTop();\n    var scrollDirection = getScrollDirection(currentScroll);\n    var visibleSectionIndex = 0;\n    var screen_mid = currentScroll + utils.getWindowHeight() / 2.0;\n    var isAtBottom = $body.scrollHeight - utils.getWindowHeight() === currentScroll;\n    var sections = getState().sections;\n    setState({\n      scrollY: currentScroll\n    });\n\n    //when using `auto-height` for a small last section it won't be centered in the viewport\n    if (isAtBottom) {\n      visibleSectionIndex = sections.length - 1;\n    }\n    //is at top? when using `auto-height` for a small first section it won't be centered in the viewport\n    else if (!currentScroll) {\n      visibleSectionIndex = 0;\n    }\n\n    //taking the section which is showing more content in the viewport\n    else {\n      for (var i = 0; i < sections.length; ++i) {\n        var section = sections[i].item;\n\n        // Pick the the last section which passes the middle line of the screen.\n        if (section.offsetTop <= screen_mid) {\n          visibleSectionIndex = i;\n        }\n      }\n    }\n    if (isCompletelyInViewPort(scrollDirection)) {\n      if (!utils.hasClass(getState().activeSection.item, COMPLETELY)) {\n        utils.addClass(getState().activeSection.item, COMPLETELY);\n        utils.removeClass(utils.siblings(getState().activeSection.item), COMPLETELY);\n      }\n    }\n\n    //geting the last one, the current one on the screen\n    currentSection = sections[visibleSectionIndex];\n    currentSectionElem = currentSection.item;\n\n    //setting the visible section as active when manually scrolling\n    //executing only once the first time we reach the section\n    if (!currentSection.isActive) {\n      setState({\n        isScrolling: true\n      });\n      var leavingSection = getState().activeSection.item;\n      var leavingSectionIndex = getState().activeSection.index() + 1;\n      var yMovement = getYmovement(getState().activeSection, currentSectionElem);\n      var anchorLink = currentSection.anchor;\n      var sectionIndex = currentSection.index() + 1;\n      var activeSlide = currentSection.activeSlide;\n      var slideIndex;\n      var slideAnchorLink;\n      var callbacksParams = {\n        activeSection: leavingSection,\n        sectionIndex: sectionIndex - 1,\n        anchorLink: anchorLink,\n        element: currentSectionElem,\n        leavingSection: leavingSectionIndex,\n        direction: yMovement,\n        items: {\n          origin: getState().activeSection,\n          destination: currentSection\n        }\n      };\n      if (activeSlide) {\n        slideAnchorLink = activeSlide.anchor;\n        slideIndex = activeSlide.index();\n      }\n      if (state.canScroll) {\n        utils.addClass(currentSectionElem, ACTIVE);\n        utils.removeClass(utils.siblings(currentSectionElem), ACTIVE);\n        if (utils.isFunction(getOptions().beforeLeave)) {\n          fireCallbackOncePerScroll('beforeLeave', callbacksParams);\n        }\n        if (utils.isFunction(getOptions().onLeave)) {\n          fireCallback('onLeave', callbacksParams);\n        }\n        if (utils.isFunction(getOptions().afterLoad)) {\n          fireCallback('afterLoad', callbacksParams);\n        }\n        stopMedia(leavingSection);\n        lazyLoad(currentSectionElem);\n        playMedia(currentSectionElem);\n        activateMenuAndNav(anchorLink, sectionIndex - 1);\n        if (getOptions().anchors.length) {\n          //needed to enter in hashChange event when using the menu with anchor links\n          setState({\n            lastScrolledDestiny: anchorLink\n          });\n        }\n        updateState();\n        setPageStatus(slideIndex, slideAnchorLink, anchorLink);\n      }\n\n      //small timeout in order to avoid entering in hashChange event when scrolling is not finished yet\n      clearTimeout(g_scrollId);\n      g_scrollId = setTimeout(function () {\n        setState({\n          isScrolling: false\n        });\n      }, 100);\n    }\n    if (getOptions().fitToSection && state.canScroll) {\n      clearTimeout(g_scrollId2);\n      g_scrollId2 = setTimeout(function () {\n        var fixedSections = state.sections.filter(function (section) {\n          var sectionValues = section.item.getBoundingClientRect();\n          return Math.round(sectionValues.bottom) === Math.round(utils.getWindowHeight()) || Math.round(sectionValues.top) === 0;\n        });\n\n        // No section is fitting the viewport? Let's fix that!\n        if (!fixedSections.length) {\n          fitToSection();\n        }\n      }, getOptions().fitToSectionDelay);\n    }\n  }\n}\nfunction onDestroy() {\n  clearTimeout(g_scrollId);\n  clearTimeout(g_scrollId2);\n}\n\n/**\n* Gets the directon of the the scrolling fired by the scroll event.\n*/\nfunction getScrollDirection(currentScroll) {\n  var direction = currentScroll > lastScroll ? 'down' : 'up';\n  lastScroll = currentScroll;\n\n  //needed for auto-height sections to determine if we want to scroll to the top or bottom of the destination\n  setState({\n    previousDestTop: currentScroll\n  });\n  return direction;\n}\n\n/**\n* Determines whether the active section has seen in its whole or not.\n*/\nfunction isCompletelyInViewPort(movement) {\n  var top = getState().activeSection.item.offsetTop;\n  var bottom = top + utils.getWindowHeight();\n  if (movement == 'up') {\n    return bottom >= utils.getScrollTop() + utils.getWindowHeight();\n  }\n  return top <= utils.getScrollTop();\n}","map":{"version":3,"names":["utils","getOptions","stopMedia","playMedia","updateState","getState","setState","state","lazyLoad","setPageStatus","activateMenuAndNav","$body","getYmovement","COMPLETELY","ACTIVE","fireCallbackOncePerScroll","fireCallback","EventEmitter","fitToSection","events","lastScroll","g_scrollId","g_scrollId2","on","onDestroy","scrollHandler","e","currentSection","currentSectionElem","isResizing","activeSection","lastSection","getLast","sections","isBeyondFullpage","isAboutToScrollToFullPage","autoScrolling","scrollBar","currentScroll","getScrollTop","scrollDirection","getScrollDirection","visibleSectionIndex","screen_mid","getWindowHeight","isAtBottom","scrollHeight","scrollY","length","i","section","item","offsetTop","isCompletelyInViewPort","hasClass","addClass","removeClass","siblings","isActive","isScrolling","leavingSection","leavingSectionIndex","index","yMovement","anchorLink","anchor","sectionIndex","activeSlide","slideIndex","slideAnchorLink","callbacksParams","element","direction","items","origin","destination","canScroll","isFunction","beforeLeave","onLeave","afterLoad","anchors","lastScrolledDestiny","clearTimeout","setTimeout","fixedSections","filter","sectionValues","getBoundingClientRect","Math","round","bottom","top","fitToSectionDelay","previousDestTop","movement"],"sources":["/Users/rachelma/college/2023/fall/2223/internet-art/src/js/scroll/scrollHandler.js"],"sourcesContent":["import * as utils from '../common/utils.js';\nimport { getOptions } from '../common/options.js';\nimport { stopMedia, playMedia} from '../media.js';\nimport { updateState } from '../stateUpdates.js';\nimport { getState, setState, state } from '../common/state.js';\nimport { lazyLoad } from '../lazyLoad/lazyLoad.js';\nimport { setPageStatus } from '../anchors/setPageStatus.js';\nimport { activateMenuAndNav } from '../menu/activateMenuAndNav.js';\nimport { $body } from '../common/cache.js';\nimport { getYmovement } from '../common/utilsFP.js';\nimport { \n    COMPLETELY,\n    ACTIVE\n} from '../common/selectors.js';\nimport { fireCallbackOncePerScroll } from '../callbacks/fireCallbacksOncePerScroll.js';\nimport { fireCallback } from '../callbacks/fireCallback.js';\nimport { EventEmitter } from '../common/eventEmitter.js';\nimport { fitToSection } from '../fitToSection.js';\nimport { events } from '../common/events.js';\n\nvar lastScroll = 0;\nlet g_scrollId;\nlet g_scrollId2;\n\nEventEmitter.on(events.onDestroy, onDestroy);\n\n//when scrolling...\nexport function scrollHandler(e){\n    var currentSection;\n    var currentSectionElem;\n\n    if(state.isResizing || !getState().activeSection){\n        return;\n    }\n\n    var lastSection = utils.getLast(getState().sections);\n    if(getState().isBeyondFullpage || getState().isAboutToScrollToFullPage){\n        return;\n    }\n    \n    if(!getOptions().autoScrolling || getOptions().scrollBar){\n        var currentScroll = utils.getScrollTop();\n        var scrollDirection = getScrollDirection(currentScroll);\n        var visibleSectionIndex = 0;\n        var screen_mid = currentScroll + (utils.getWindowHeight() / 2.0);\n        var isAtBottom = $body.scrollHeight - utils.getWindowHeight() === currentScroll;\n        var sections =  getState().sections;\n        \n        setState({scrollY: currentScroll});\n\n        //when using `auto-height` for a small last section it won't be centered in the viewport\n        if(isAtBottom){\n            visibleSectionIndex = sections.length - 1;\n        }\n        //is at top? when using `auto-height` for a small first section it won't be centered in the viewport\n        else if(!currentScroll){\n            visibleSectionIndex = 0;\n        }\n\n        //taking the section which is showing more content in the viewport\n        else{\n            for (var i = 0; i < sections.length; ++i) {\n                var section = sections[i].item;\n\n                // Pick the the last section which passes the middle line of the screen.\n                if (section.offsetTop <= screen_mid)\n                {\n                    visibleSectionIndex = i;\n                }\n            }\n        }\n\n        if(isCompletelyInViewPort(scrollDirection)){\n            if(!utils.hasClass(getState().activeSection.item, COMPLETELY)){\n                utils.addClass(getState().activeSection.item, COMPLETELY);\n                utils.removeClass(utils.siblings(getState().activeSection.item), COMPLETELY);\n            }\n        }\n\n        //geting the last one, the current one on the screen\n        currentSection = sections[visibleSectionIndex];\n        currentSectionElem = currentSection.item;\n\n        //setting the visible section as active when manually scrolling\n        //executing only once the first time we reach the section\n        if(!currentSection.isActive){\n            setState({isScrolling: true});\n            var leavingSection = getState().activeSection.item;\n            var leavingSectionIndex = getState().activeSection.index() + 1;\n            var yMovement = getYmovement(getState().activeSection, currentSectionElem);\n            var anchorLink  = currentSection.anchor;\n            var sectionIndex = currentSection.index() + 1;\n            var activeSlide = currentSection.activeSlide;\n            var slideIndex;\n            var slideAnchorLink;\n            var callbacksParams = {\n                activeSection: leavingSection,\n                sectionIndex: sectionIndex -1,\n                anchorLink: anchorLink,\n                element: currentSectionElem,\n                leavingSection: leavingSectionIndex,\n                direction: yMovement,\n\n                items: {\n                    origin: getState().activeSection,\n                    destination: currentSection\n                }\n            };\n\n            if(activeSlide){\n                slideAnchorLink = activeSlide.anchor;\n                slideIndex = activeSlide.index();\n            }\n\n            if(state.canScroll){\n                utils.addClass(currentSectionElem, ACTIVE);\n                utils.removeClass(utils.siblings(currentSectionElem), ACTIVE);\n\n                if(utils.isFunction( getOptions().beforeLeave )){\n                    fireCallbackOncePerScroll('beforeLeave', callbacksParams);\n                }\n\n                if(utils.isFunction( getOptions().onLeave )){\n                    fireCallback('onLeave', callbacksParams);\n                }\n                if(utils.isFunction( getOptions().afterLoad )){\n                    fireCallback('afterLoad', callbacksParams);\n                }\n\n                stopMedia(leavingSection);\n                lazyLoad(currentSectionElem);\n                playMedia(currentSectionElem);\n\n                activateMenuAndNav(anchorLink, sectionIndex - 1);\n\n                if(getOptions().anchors.length){\n                    //needed to enter in hashChange event when using the menu with anchor links\n                    setState({lastScrolledDestiny: anchorLink});\n                }\n                updateState();\n                setPageStatus(slideIndex, slideAnchorLink, anchorLink);\n            }\n\n            //small timeout in order to avoid entering in hashChange event when scrolling is not finished yet\n            clearTimeout(g_scrollId);\n            g_scrollId = setTimeout(function(){\n                setState({isScrolling: false});\n            }, 100);\n\n        }\n\n            \n        if(getOptions().fitToSection && state.canScroll){\n\n            clearTimeout(g_scrollId2);\n            g_scrollId2 = setTimeout(function(){\n\n                var fixedSections = state.sections.filter(function(section){\n                    var sectionValues = section.item.getBoundingClientRect();\n                    return Math.round(sectionValues.bottom) === Math.round(utils.getWindowHeight()) ||\n                        Math.round(sectionValues.top) === 0;\n                });\n\n                // No section is fitting the viewport? Let's fix that!\n                if(!fixedSections.length){\n                    fitToSection();\n                }\n            }, getOptions().fitToSectionDelay);   \n        }\n    }\n}\n\nfunction onDestroy(){\n    clearTimeout(g_scrollId);\n    clearTimeout(g_scrollId2);\n}\n\n/**\n* Gets the directon of the the scrolling fired by the scroll event.\n*/\nfunction getScrollDirection(currentScroll){\n    var direction = currentScroll > lastScroll ? 'down' : 'up';\n\n    lastScroll = currentScroll;\n\n    //needed for auto-height sections to determine if we want to scroll to the top or bottom of the destination\n    setState({previousDestTop: currentScroll});\n\n    return direction;\n}\n\n\n\n/**\n* Determines whether the active section has seen in its whole or not.\n*/\nfunction isCompletelyInViewPort(movement){\n    var top = getState().activeSection.item.offsetTop;\n    var bottom = top + utils.getWindowHeight();\n\n    if(movement == 'up'){\n        return bottom >= (utils.getScrollTop() + utils.getWindowHeight());\n    }\n    return top <= utils.getScrollTop();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}