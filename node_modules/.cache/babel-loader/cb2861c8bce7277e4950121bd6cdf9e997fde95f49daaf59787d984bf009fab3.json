{"ast":null,"code":"import * as utils from '../common/utils.js';\nimport { getOptions } from '../common/options.js';\nimport { getState, setState, state } from '../common/state.js';\nimport { doc, FP } from '../common/constants.js';\nimport { $html, $htmlBody } from '../common/cache.js';\nimport { transformContainer } from '../common/transformContainer.js';\nimport { scrollTo } from '../common/scrollTo.js';\nimport { getScrollSettings, getYmovement } from '../common/utilsFP.js';\nimport { createInfiniteSections } from '../infiniteScroll/createInfiniteSections.js';\nimport { continuousVerticalFixSectionOrder } from '../infiniteScroll/fixPosition.js';\nimport { stopMedia, playMedia } from '../media.js';\nimport { updateState } from '../stateUpdates.js';\nimport { lazyLoad } from '../lazyLoad/lazyLoad.js';\nimport { lazyLoadOthers } from '../lazyLoad/lazyLoadOthers.js';\nimport { scrollOverflowHandler } from '../scrolloverflow.js';\nimport { setPageStatus } from '../anchors/setPageStatus.js';\nimport { activateMenuAndNav } from '../menu/activateMenuAndNav.js';\nimport { AUTO_HEIGHT, COMPLETELY, ACTIVE, SECTION_ACTIVE_SEL } from '../common/selectors.js';\nimport { fireCallbackOncePerScroll } from '../callbacks/fireCallbacksOncePerScroll.js';\nimport { fireCallback } from '../callbacks/fireCallback.js';\nimport { EventEmitter } from '../common/eventEmitter.js';\nimport { events } from '../common/events.js';\nFP.moveTo = moveTo;\nFP.getScrollY = function () {\n  return state.scrollY;\n};\nlet g_afterSectionLoadsId;\nlet g_transitionLapseId;\nEventEmitter.on(events.onDestroy, onDestroy);\n\n/**\n* Scrolls the site to the given element and scrolls to the slide if a callback is given.\n*/\nexport function scrollPage(section, callback, isMovementUp) {\n  var element = section.item;\n  if (element == null) {\n    return;\n  } //there's no element to scroll, leaving the function\n\n  var dtop = getDestinationPosition(element);\n  var slideAnchorLink;\n  var slideIndex;\n\n  //local variables\n  var v = {\n    \"element\": element,\n    \"callback\": callback,\n    \"isMovementUp\": isMovementUp,\n    \"dtop\": dtop,\n    \"yMovement\": getYmovement(getState().activeSection, element),\n    \"anchorLink\": section.anchor,\n    \"sectionIndex\": section.index(),\n    \"activeSlide\": section.activeSlide ? section.activeSlide.item : null,\n    \"leavingSection\": getState().activeSection.index() + 1,\n    //caching the value of isResizing at the momment the function is called\n    //because it will be checked later inside a setTimeout and the value might change\n    \"localIsResizing\": state.isResizing,\n    \"items\": {\n      \"origin\": getState().activeSection,\n      \"destination\": section\n    },\n    \"direction\": null\n  };\n\n  //quiting when destination scroll is the same as the current one\n  if (getState().activeSection.item == element && !state.isResizing || getOptions().scrollBar && utils.getScrollTop() === v.dtop && !utils.hasClass(element, AUTO_HEIGHT)) {\n    return;\n  }\n  if (v.activeSlide != null) {\n    slideAnchorLink = utils.getAttr(v.activeSlide, 'data-anchor');\n    slideIndex = utils.index(v.activeSlide, null);\n  }\n\n  //callback (onLeave) if the site is not just resizing and readjusting the slides\n  if (!v.localIsResizing) {\n    var direction = v.yMovement;\n\n    //required for continousVertical\n    if (typeof isMovementUp !== 'undefined') {\n      direction = isMovementUp ? 'up' : 'down';\n    }\n\n    //for the callback\n    v.direction = direction;\n    if (utils.isFunction(getOptions().beforeLeave)) {\n      if (fireCallbackOncePerScroll('beforeLeave', v) === false) {\n        return;\n      }\n    }\n    if (utils.isFunction(getOptions().onLeave)) {\n      if (!fireCallback('onLeave', v)) {\n        return;\n      }\n    }\n  }\n\n  // If continuousVertical && we need to wrap around\n  if (getOptions().autoScrolling && getOptions().continuousVertical && typeof v.isMovementUp !== \"undefined\" && (!v.isMovementUp && v.yMovement == 'up' ||\n  // Intending to scroll down but about to go up or\n  v.isMovementUp && v.yMovement == 'down')) {\n    // intending to scroll up but about to go down\n\n    v = createInfiniteSections(v);\n  }\n\n  //pausing media of the leaving section (if we are not just resizing, as destinatino will be the same one)\n  if (!v.localIsResizing) {\n    stopMedia(getState().activeSection.item);\n  }\n  utils.addClass(element, ACTIVE);\n  utils.removeClass(utils.siblings(element), ACTIVE);\n  updateState();\n  lazyLoad(element);\n\n  //preventing from activating the MouseWheelHandler event\n  //more than once if the page is scrolling\n  setState({\n    canScroll: false || FP.test.isTesting\n  });\n  setPageStatus(slideIndex, slideAnchorLink, v.anchorLink);\n  EventEmitter.emit(events.onLeave, v);\n  performMovement(v);\n\n  //flag to avoid callingn `scrollPage()` twice in case of using anchor links\n  setState({\n    lastScrolledDestiny: v.anchorLink\n  });\n\n  //avoid firing it twice (as it does also on scroll)\n  activateMenuAndNav(v.anchorLink, v.sectionIndex);\n}\nfunction onDestroy() {\n  clearTimeout(g_afterSectionLoadsId);\n  clearTimeout(g_transitionLapseId);\n}\n\n/**\n* Returns the destination Y position based on the scrolling direction and\n* the height of the section.\n*/\nfunction getDestinationPosition(element) {\n  var elementHeight = element.offsetHeight;\n  var elementTop = element.offsetTop;\n\n  //top of the desination will be at the top of the viewport\n  var position = elementTop;\n  var isScrollingDown = elementTop > state.previousDestTop;\n  var sectionBottom = position - utils.getWindowHeight() + elementHeight;\n  var bigSectionsDestination = getOptions().bigSectionsDestination;\n\n  //is the destination element bigger than the viewport?\n  if (elementHeight > utils.getWindowHeight()) {\n    //scrolling up?\n    if (!isScrollingDown && !bigSectionsDestination || bigSectionsDestination === 'bottom') {\n      position = sectionBottom;\n    }\n  }\n\n  //sections equal or smaller than the viewport height && scrolling down? ||  is resizing and its in the last section\n  else if (isScrollingDown || state.isResizing && utils.next(element) == null) {\n    //The bottom of the destination will be at the bottom of the viewport\n    position = sectionBottom;\n  }\n\n  /*\n  Keeping record of the last scrolled position to determine the scrolling direction.\n  No conventional methods can be used as the scroll bar might not be present\n  AND the section might not be active if it is auto-height and didnt reach the middle\n  of the viewport.\n  */\n  setState({\n    previousDestTop: position\n  });\n  return position;\n}\n\n/**\n* Performs the vertical movement (by CSS3 or by jQuery)\n*/\nfunction performMovement(v) {\n  var isFastSpeed = getOptions().scrollingSpeed < 700;\n  var transitionLapse = isFastSpeed ? 700 : getOptions().scrollingSpeed;\n  setState({\n    touchDirection: 'none',\n    scrollY: Math.round(v.dtop)\n  });\n  EventEmitter.emit(events.onPerformMovement);\n\n  // using CSS3 translate functionality\n  if (getOptions().css3 && getOptions().autoScrolling && !getOptions().scrollBar) {\n    // The first section can have a negative value in iOS 10. Not quite sure why: -0.0142822265625\n    // that's why we round it to 0.\n    var translate3d = 'translate3d(0px, -' + Math.round(v.dtop) + 'px, 0px)';\n    transformContainer(translate3d, true);\n\n    //even when the scrollingSpeed is 0 there's a little delay, which might cause the\n    //scrollingSpeed to change in case of using silentMoveTo();รง\n    if (getOptions().scrollingSpeed) {\n      clearTimeout(g_afterSectionLoadsId);\n      g_afterSectionLoadsId = setTimeout(function () {\n        afterSectionLoads(v);\n\n        //disabling canScroll when using fastSpeed\n        setState({\n          canScroll: !isFastSpeed || FP.test.isTesting\n        });\n      }, getOptions().scrollingSpeed);\n    } else {\n      afterSectionLoads(v);\n    }\n  }\n\n  // using JS to animate\n  else {\n    var scrollSettings = getScrollSettings(v.dtop);\n    FP.test.top = -v.dtop + 'px';\n    clearTimeout(g_afterSectionLoadsId);\n    scrollTo(scrollSettings.element, scrollSettings.options, getOptions().scrollingSpeed, function () {\n      if (getOptions().scrollBar) {\n        /* Hack!\n        The timeout prevents setting the most dominant section in the viewport as \"active\" when the user\n        scrolled to a smaller section by using the mousewheel (auto scrolling) rather than draging the scroll bar.\n         When using scrollBar:true It seems like the scroll events still getting propagated even after the scrolling animation has finished.\n        */\n        g_afterSectionLoadsId = setTimeout(function () {\n          afterSectionLoads(v);\n        }, 30);\n      } else {\n        afterSectionLoads(v);\n\n        //disabling canScroll when using fastSpeed\n        setState({\n          canScroll: !isFastSpeed || FP.test.isTesting\n        });\n      }\n    });\n  }\n\n  // enabling canScroll after the minimum transition laps\n  if (isFastSpeed) {\n    clearTimeout(g_transitionLapseId);\n    g_transitionLapseId = setTimeout(function () {\n      setState({\n        canScroll: true\n      });\n    }, transitionLapse);\n  }\n}\n\n/**\n* Actions to do once the section is loaded.\n*/\nfunction afterSectionLoads(v) {\n  setState({\n    isBeyondFullpage: false\n  });\n  continuousVerticalFixSectionOrder(v);\n\n  //callback (afterLoad) if the site is not just resizing and readjusting the slides\n  if (utils.isFunction(getOptions().afterLoad) && !v.localIsResizing) {\n    fireCallback('afterLoad', v);\n  }\n  updateState();\n  if (!v.localIsResizing) {\n    playMedia(v.element);\n  }\n  utils.addClass(v.element, COMPLETELY);\n  utils.removeClass(utils.siblings(v.element), COMPLETELY);\n  lazyLoadOthers();\n  setState({\n    canScroll: true\n  });\n  EventEmitter.emit(events.afterSectionLoads, v);\n  if (utils.isFunction(v.callback)) {\n    v.callback();\n  }\n}","map":{"version":3,"names":["utils","getOptions","getState","setState","state","doc","FP","$html","$htmlBody","transformContainer","scrollTo","getScrollSettings","getYmovement","createInfiniteSections","continuousVerticalFixSectionOrder","stopMedia","playMedia","updateState","lazyLoad","lazyLoadOthers","scrollOverflowHandler","setPageStatus","activateMenuAndNav","AUTO_HEIGHT","COMPLETELY","ACTIVE","SECTION_ACTIVE_SEL","fireCallbackOncePerScroll","fireCallback","EventEmitter","events","moveTo","getScrollY","scrollY","g_afterSectionLoadsId","g_transitionLapseId","on","onDestroy","scrollPage","section","callback","isMovementUp","element","item","dtop","getDestinationPosition","slideAnchorLink","slideIndex","v","activeSection","anchor","index","activeSlide","isResizing","scrollBar","getScrollTop","hasClass","getAttr","localIsResizing","direction","yMovement","isFunction","beforeLeave","onLeave","autoScrolling","continuousVertical","addClass","removeClass","siblings","canScroll","test","isTesting","anchorLink","emit","performMovement","lastScrolledDestiny","sectionIndex","clearTimeout","elementHeight","offsetHeight","elementTop","offsetTop","position","isScrollingDown","previousDestTop","sectionBottom","getWindowHeight","bigSectionsDestination","next","isFastSpeed","scrollingSpeed","transitionLapse","touchDirection","Math","round","onPerformMovement","css3","translate3d","setTimeout","afterSectionLoads","scrollSettings","top","options","isBeyondFullpage","afterLoad"],"sources":["/Users/rachelma/college/2023/fall/2223/internet-art/src/js/scroll/scrollPage.js"],"sourcesContent":["import * as utils from '../common/utils.js';\nimport { getOptions } from '../common/options.js';\nimport { getState, setState, state } from '../common/state.js';\nimport { doc, FP } from '../common/constants.js';\nimport { $html, $htmlBody } from '../common/cache.js';\nimport { transformContainer } from '../common/transformContainer.js';\nimport { scrollTo } from '../common/scrollTo.js';\nimport { getScrollSettings, getYmovement } from '../common/utilsFP.js';\nimport { createInfiniteSections } from '../infiniteScroll/createInfiniteSections.js';\nimport { continuousVerticalFixSectionOrder } from '../infiniteScroll/fixPosition.js';\nimport { stopMedia, playMedia} from '../media.js';\nimport { updateState } from '../stateUpdates.js';\nimport { lazyLoad } from '../lazyLoad/lazyLoad.js';\nimport { lazyLoadOthers } from '../lazyLoad/lazyLoadOthers.js';\nimport { scrollOverflowHandler } from '../scrolloverflow.js';\nimport { setPageStatus } from '../anchors/setPageStatus.js';\nimport { activateMenuAndNav } from '../menu/activateMenuAndNav.js';\nimport { \n    AUTO_HEIGHT,\n    COMPLETELY,\n    ACTIVE,\n    SECTION_ACTIVE_SEL\n} from '../common/selectors.js';\nimport { fireCallbackOncePerScroll } from '../callbacks/fireCallbacksOncePerScroll.js';\nimport { fireCallback } from '../callbacks/fireCallback.js';\nimport { EventEmitter } from '../common/eventEmitter.js';\nimport { events } from '../common/events.js';\n\nFP.moveTo = moveTo;\nFP.getScrollY = function(){\n    return state.scrollY;\n};\n\nlet g_afterSectionLoadsId;\nlet g_transitionLapseId;\n\nEventEmitter.on(events.onDestroy, onDestroy);\n\n/**\n* Scrolls the site to the given element and scrolls to the slide if a callback is given.\n*/\nexport function scrollPage(section, callback, isMovementUp){\n    var element = section.item;\n    if(element == null){ return; } //there's no element to scroll, leaving the function\n\n    var dtop = getDestinationPosition(element);\n    var slideAnchorLink;\n    var slideIndex;\n\n    //local variables\n    var v = {\n        \"element\": element,\n        \"callback\": callback,\n        \"isMovementUp\": isMovementUp,\n        \"dtop\": dtop,\n        \"yMovement\": getYmovement(getState().activeSection, element),\n        \"anchorLink\": section.anchor,\n        \"sectionIndex\": section.index(),\n        \"activeSlide\": section.activeSlide ? section.activeSlide.item : null,\n        \"leavingSection\": getState().activeSection.index() + 1,\n\n        //caching the value of isResizing at the momment the function is called\n        //because it will be checked later inside a setTimeout and the value might change\n        \"localIsResizing\": state.isResizing,\n\n        \"items\": {\n            \"origin\": getState().activeSection,\n            \"destination\": section\n        },\n        \"direction\": null\n    };\n\n    //quiting when destination scroll is the same as the current one\n    if((getState().activeSection.item == element && !state.isResizing) || (getOptions().scrollBar && utils.getScrollTop() === v.dtop && !utils.hasClass(element, AUTO_HEIGHT) )){ \n        return; \n    }\n\n    if(v.activeSlide != null){\n        slideAnchorLink = utils.getAttr(v.activeSlide, 'data-anchor');\n        slideIndex = utils.index(v.activeSlide, null);\n    }\n\n    //callback (onLeave) if the site is not just resizing and readjusting the slides\n    if(!v.localIsResizing){\n        var direction = v.yMovement;\n\n        //required for continousVertical\n        if(typeof isMovementUp !== 'undefined'){\n            direction = isMovementUp ? 'up' : 'down';\n        }\n\n        //for the callback\n        v.direction = direction;\n\n        if(utils.isFunction( getOptions().beforeLeave )){\n            \n            if(fireCallbackOncePerScroll('beforeLeave', v) === false){\n                return;\n            }\n        }\n\n        if(utils.isFunction(getOptions().onLeave)){\n            if(!fireCallback('onLeave', v)){\n                return;\n            }\n        }\n    }\n\n    // If continuousVertical && we need to wrap around\n    if (getOptions().autoScrolling && getOptions().continuousVertical && typeof (v.isMovementUp) !== \"undefined\" &&\n        ((!v.isMovementUp && v.yMovement == 'up') || // Intending to scroll down but about to go up or\n        (v.isMovementUp && v.yMovement == 'down'))) { // intending to scroll up but about to go down\n\n        v = createInfiniteSections(v);\n    }\n\n    //pausing media of the leaving section (if we are not just resizing, as destinatino will be the same one)\n    if(!v.localIsResizing){\n        stopMedia(getState().activeSection.item);\n    }\n\n    utils.addClass(element, ACTIVE);\n    utils.removeClass(utils.siblings(element), ACTIVE);\n    updateState();\n    lazyLoad(element);\n\n    //preventing from activating the MouseWheelHandler event\n    //more than once if the page is scrolling\n    setState({canScroll: false || FP.test.isTesting});\n\n    setPageStatus(slideIndex, slideAnchorLink, v.anchorLink);\n\n    EventEmitter.emit(events.onLeave, v);\n\n    performMovement(v);\n\n    //flag to avoid callingn `scrollPage()` twice in case of using anchor links\n    setState({lastScrolledDestiny: v.anchorLink});\n\n    //avoid firing it twice (as it does also on scroll)\n    activateMenuAndNav(v.anchorLink, v.sectionIndex);\n}\n\nfunction onDestroy(){\n    clearTimeout(g_afterSectionLoadsId);\n    clearTimeout(g_transitionLapseId);\n}\n\n\n/**\n* Returns the destination Y position based on the scrolling direction and\n* the height of the section.\n*/\nfunction getDestinationPosition(element){\n    var elementHeight = element.offsetHeight;\n    var elementTop = element.offsetTop;\n\n    //top of the desination will be at the top of the viewport\n    var position = elementTop;\n    var isScrollingDown =  elementTop > state.previousDestTop;\n    var sectionBottom = position - utils.getWindowHeight() + elementHeight;\n    var bigSectionsDestination = getOptions().bigSectionsDestination;\n\n    //is the destination element bigger than the viewport?\n    if(elementHeight > utils.getWindowHeight()){\n        //scrolling up?\n        if(!isScrollingDown && !bigSectionsDestination || bigSectionsDestination === 'bottom' ){\n            position = sectionBottom;\n        }\n    }\n\n    //sections equal or smaller than the viewport height && scrolling down? ||  is resizing and its in the last section\n    else if(isScrollingDown || (state.isResizing && utils.next(element) == null) ){\n        //The bottom of the destination will be at the bottom of the viewport\n        position = sectionBottom;\n    }\n\n    /*\n    Keeping record of the last scrolled position to determine the scrolling direction.\n    No conventional methods can be used as the scroll bar might not be present\n    AND the section might not be active if it is auto-height and didnt reach the middle\n    of the viewport.\n    */\n    setState({previousDestTop: position});\n    return position;\n}\n\n/**\n* Performs the vertical movement (by CSS3 or by jQuery)\n*/\nfunction performMovement(v){\n    var isFastSpeed = getOptions().scrollingSpeed < 700;\n    var transitionLapse = isFastSpeed ? 700 : getOptions().scrollingSpeed; \n    setState({\n        touchDirection: 'none',\n        scrollY: Math.round(v.dtop)\n    });\n\n    EventEmitter.emit(events.onPerformMovement);\n\n    // using CSS3 translate functionality\n    if (getOptions().css3 && getOptions().autoScrolling && !getOptions().scrollBar) {\n\n        // The first section can have a negative value in iOS 10. Not quite sure why: -0.0142822265625\n        // that's why we round it to 0.\n        var translate3d = 'translate3d(0px, -' + Math.round(v.dtop) + 'px, 0px)';\n        transformContainer(translate3d, true);\n\n        //even when the scrollingSpeed is 0 there's a little delay, which might cause the\n        //scrollingSpeed to change in case of using silentMoveTo();รง\n        if(getOptions().scrollingSpeed){\n            clearTimeout(g_afterSectionLoadsId);\n            g_afterSectionLoadsId = setTimeout(function () {\n                afterSectionLoads(v);\n\n                //disabling canScroll when using fastSpeed\n                setState({canScroll: !isFastSpeed || FP.test.isTesting});\n            }, getOptions().scrollingSpeed);                   \n        }else{\n            afterSectionLoads(v);\n        }\n    }\n\n    // using JS to animate\n    else{\n        var scrollSettings = getScrollSettings(v.dtop);\n        FP.test.top = -v.dtop + 'px';\n\n        clearTimeout(g_afterSectionLoadsId);\n\n        scrollTo(scrollSettings.element, scrollSettings.options, getOptions().scrollingSpeed, function(){\n            if(getOptions().scrollBar){\n\n                /* Hack!\n                The timeout prevents setting the most dominant section in the viewport as \"active\" when the user\n                scrolled to a smaller section by using the mousewheel (auto scrolling) rather than draging the scroll bar.\n\n                When using scrollBar:true It seems like the scroll events still getting propagated even after the scrolling animation has finished.\n                */\n                g_afterSectionLoadsId = setTimeout(function(){\n                    afterSectionLoads(v);\n                },30);\n            }else{\n                \n                afterSectionLoads(v);\n\n                //disabling canScroll when using fastSpeed\n                setState({canScroll: !isFastSpeed || FP.test.isTesting});\n            }\n        });\n    }\n\n    // enabling canScroll after the minimum transition laps\n    if(isFastSpeed){\n        clearTimeout(g_transitionLapseId);\n        g_transitionLapseId = setTimeout(function(){\n            setState({canScroll: true});\n        }, transitionLapse);\n    }\n}\n\n/**\n* Actions to do once the section is loaded.\n*/\nfunction afterSectionLoads(v){    \n    setState({isBeyondFullpage: false});\n    continuousVerticalFixSectionOrder(v);\n\n    //callback (afterLoad) if the site is not just resizing and readjusting the slides\n    if(utils.isFunction(getOptions().afterLoad) && !v.localIsResizing){\n        fireCallback('afterLoad', v);\n    }\n\n    updateState();\n\n    if(!v.localIsResizing){\n        playMedia(v.element);\n    }\n\n    utils.addClass(v.element, COMPLETELY);\n    utils.removeClass(utils.siblings(v.element), COMPLETELY);\n\n    lazyLoadOthers();\n\n    setState({canScroll: true});\n\n    EventEmitter.emit(events.afterSectionLoads, v);\n\n    if(utils.isFunction(v.callback)){\n        v.callback();\n    }\n}\n"],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,oBAAoB;AAC3C,SAASC,UAAU,QAAQ,sBAAsB;AACjD,SAASC,QAAQ,EAAEC,QAAQ,EAAEC,KAAK,QAAQ,oBAAoB;AAC9D,SAASC,GAAG,EAAEC,EAAE,QAAQ,wBAAwB;AAChD,SAASC,KAAK,EAAEC,SAAS,QAAQ,oBAAoB;AACrD,SAASC,kBAAkB,QAAQ,iCAAiC;AACpE,SAASC,QAAQ,QAAQ,uBAAuB;AAChD,SAASC,iBAAiB,EAAEC,YAAY,QAAQ,sBAAsB;AACtE,SAASC,sBAAsB,QAAQ,6CAA6C;AACpF,SAASC,iCAAiC,QAAQ,kCAAkC;AACpF,SAASC,SAAS,EAAEC,SAAS,QAAO,aAAa;AACjD,SAASC,WAAW,QAAQ,oBAAoB;AAChD,SAASC,QAAQ,QAAQ,yBAAyB;AAClD,SAASC,cAAc,QAAQ,+BAA+B;AAC9D,SAASC,qBAAqB,QAAQ,sBAAsB;AAC5D,SAASC,aAAa,QAAQ,6BAA6B;AAC3D,SAASC,kBAAkB,QAAQ,+BAA+B;AAClE,SACIC,WAAW,EACXC,UAAU,EACVC,MAAM,EACNC,kBAAkB,QACf,wBAAwB;AAC/B,SAASC,yBAAyB,QAAQ,4CAA4C;AACtF,SAASC,YAAY,QAAQ,8BAA8B;AAC3D,SAASC,YAAY,QAAQ,2BAA2B;AACxD,SAASC,MAAM,QAAQ,qBAAqB;AAE5CxB,EAAE,CAACyB,MAAM,GAAGA,MAAM;AAClBzB,EAAE,CAAC0B,UAAU,GAAG,YAAU;EACtB,OAAO5B,KAAK,CAAC6B,OAAO;AACxB,CAAC;AAED,IAAIC,qBAAqB;AACzB,IAAIC,mBAAmB;AAEvBN,YAAY,CAACO,EAAE,CAACN,MAAM,CAACO,SAAS,EAAEA,SAAS,CAAC;;AAE5C;AACA;AACA;AACA,OAAO,SAASC,UAAUA,CAACC,OAAO,EAAEC,QAAQ,EAAEC,YAAY,EAAC;EACvD,IAAIC,OAAO,GAAGH,OAAO,CAACI,IAAI;EAC1B,IAAGD,OAAO,IAAI,IAAI,EAAC;IAAE;EAAQ,CAAC,CAAC;;EAE/B,IAAIE,IAAI,GAAGC,sBAAsB,CAACH,OAAO,CAAC;EAC1C,IAAII,eAAe;EACnB,IAAIC,UAAU;;EAEd;EACA,IAAIC,CAAC,GAAG;IACJ,SAAS,EAAEN,OAAO;IAClB,UAAU,EAAEF,QAAQ;IACpB,cAAc,EAAEC,YAAY;IAC5B,MAAM,EAAEG,IAAI;IACZ,WAAW,EAAEhC,YAAY,CAACV,QAAQ,CAAC,CAAC,CAAC+C,aAAa,EAAEP,OAAO,CAAC;IAC5D,YAAY,EAAEH,OAAO,CAACW,MAAM;IAC5B,cAAc,EAAEX,OAAO,CAACY,KAAK,CAAC,CAAC;IAC/B,aAAa,EAAEZ,OAAO,CAACa,WAAW,GAAGb,OAAO,CAACa,WAAW,CAACT,IAAI,GAAG,IAAI;IACpE,gBAAgB,EAAEzC,QAAQ,CAAC,CAAC,CAAC+C,aAAa,CAACE,KAAK,CAAC,CAAC,GAAG,CAAC;IAEtD;IACA;IACA,iBAAiB,EAAE/C,KAAK,CAACiD,UAAU;IAEnC,OAAO,EAAE;MACL,QAAQ,EAAEnD,QAAQ,CAAC,CAAC,CAAC+C,aAAa;MAClC,aAAa,EAAEV;IACnB,CAAC;IACD,WAAW,EAAE;EACjB,CAAC;;EAED;EACA,IAAIrC,QAAQ,CAAC,CAAC,CAAC+C,aAAa,CAACN,IAAI,IAAID,OAAO,IAAI,CAACtC,KAAK,CAACiD,UAAU,IAAMpD,UAAU,CAAC,CAAC,CAACqD,SAAS,IAAItD,KAAK,CAACuD,YAAY,CAAC,CAAC,KAAKP,CAAC,CAACJ,IAAI,IAAI,CAAC5C,KAAK,CAACwD,QAAQ,CAACd,OAAO,EAAEnB,WAAW,CAAG,EAAC;IACxK;EACJ;EAEA,IAAGyB,CAAC,CAACI,WAAW,IAAI,IAAI,EAAC;IACrBN,eAAe,GAAG9C,KAAK,CAACyD,OAAO,CAACT,CAAC,CAACI,WAAW,EAAE,aAAa,CAAC;IAC7DL,UAAU,GAAG/C,KAAK,CAACmD,KAAK,CAACH,CAAC,CAACI,WAAW,EAAE,IAAI,CAAC;EACjD;;EAEA;EACA,IAAG,CAACJ,CAAC,CAACU,eAAe,EAAC;IAClB,IAAIC,SAAS,GAAGX,CAAC,CAACY,SAAS;;IAE3B;IACA,IAAG,OAAOnB,YAAY,KAAK,WAAW,EAAC;MACnCkB,SAAS,GAAGlB,YAAY,GAAG,IAAI,GAAG,MAAM;IAC5C;;IAEA;IACAO,CAAC,CAACW,SAAS,GAAGA,SAAS;IAEvB,IAAG3D,KAAK,CAAC6D,UAAU,CAAE5D,UAAU,CAAC,CAAC,CAAC6D,WAAY,CAAC,EAAC;MAE5C,IAAGnC,yBAAyB,CAAC,aAAa,EAAEqB,CAAC,CAAC,KAAK,KAAK,EAAC;QACrD;MACJ;IACJ;IAEA,IAAGhD,KAAK,CAAC6D,UAAU,CAAC5D,UAAU,CAAC,CAAC,CAAC8D,OAAO,CAAC,EAAC;MACtC,IAAG,CAACnC,YAAY,CAAC,SAAS,EAAEoB,CAAC,CAAC,EAAC;QAC3B;MACJ;IACJ;EACJ;;EAEA;EACA,IAAI/C,UAAU,CAAC,CAAC,CAAC+D,aAAa,IAAI/D,UAAU,CAAC,CAAC,CAACgE,kBAAkB,IAAI,OAAQjB,CAAC,CAACP,YAAa,KAAK,WAAW,KACtG,CAACO,CAAC,CAACP,YAAY,IAAIO,CAAC,CAACY,SAAS,IAAI,IAAI;EAAK;EAC5CZ,CAAC,CAACP,YAAY,IAAIO,CAAC,CAACY,SAAS,IAAI,MAAO,CAAC,EAAE;IAAE;;IAE9CZ,CAAC,GAAGnC,sBAAsB,CAACmC,CAAC,CAAC;EACjC;;EAEA;EACA,IAAG,CAACA,CAAC,CAACU,eAAe,EAAC;IAClB3C,SAAS,CAACb,QAAQ,CAAC,CAAC,CAAC+C,aAAa,CAACN,IAAI,CAAC;EAC5C;EAEA3C,KAAK,CAACkE,QAAQ,CAACxB,OAAO,EAAEjB,MAAM,CAAC;EAC/BzB,KAAK,CAACmE,WAAW,CAACnE,KAAK,CAACoE,QAAQ,CAAC1B,OAAO,CAAC,EAAEjB,MAAM,CAAC;EAClDR,WAAW,CAAC,CAAC;EACbC,QAAQ,CAACwB,OAAO,CAAC;;EAEjB;EACA;EACAvC,QAAQ,CAAC;IAACkE,SAAS,EAAE,KAAK,IAAI/D,EAAE,CAACgE,IAAI,CAACC;EAAS,CAAC,CAAC;EAEjDlD,aAAa,CAAC0B,UAAU,EAAED,eAAe,EAAEE,CAAC,CAACwB,UAAU,CAAC;EAExD3C,YAAY,CAAC4C,IAAI,CAAC3C,MAAM,CAACiC,OAAO,EAAEf,CAAC,CAAC;EAEpC0B,eAAe,CAAC1B,CAAC,CAAC;;EAElB;EACA7C,QAAQ,CAAC;IAACwE,mBAAmB,EAAE3B,CAAC,CAACwB;EAAU,CAAC,CAAC;;EAE7C;EACAlD,kBAAkB,CAAC0B,CAAC,CAACwB,UAAU,EAAExB,CAAC,CAAC4B,YAAY,CAAC;AACpD;AAEA,SAASvC,SAASA,CAAA,EAAE;EAChBwC,YAAY,CAAC3C,qBAAqB,CAAC;EACnC2C,YAAY,CAAC1C,mBAAmB,CAAC;AACrC;;AAGA;AACA;AACA;AACA;AACA,SAASU,sBAAsBA,CAACH,OAAO,EAAC;EACpC,IAAIoC,aAAa,GAAGpC,OAAO,CAACqC,YAAY;EACxC,IAAIC,UAAU,GAAGtC,OAAO,CAACuC,SAAS;;EAElC;EACA,IAAIC,QAAQ,GAAGF,UAAU;EACzB,IAAIG,eAAe,GAAIH,UAAU,GAAG5E,KAAK,CAACgF,eAAe;EACzD,IAAIC,aAAa,GAAGH,QAAQ,GAAGlF,KAAK,CAACsF,eAAe,CAAC,CAAC,GAAGR,aAAa;EACtE,IAAIS,sBAAsB,GAAGtF,UAAU,CAAC,CAAC,CAACsF,sBAAsB;;EAEhE;EACA,IAAGT,aAAa,GAAG9E,KAAK,CAACsF,eAAe,CAAC,CAAC,EAAC;IACvC;IACA,IAAG,CAACH,eAAe,IAAI,CAACI,sBAAsB,IAAIA,sBAAsB,KAAK,QAAQ,EAAE;MACnFL,QAAQ,GAAGG,aAAa;IAC5B;EACJ;;EAEA;EAAA,KACK,IAAGF,eAAe,IAAK/E,KAAK,CAACiD,UAAU,IAAIrD,KAAK,CAACwF,IAAI,CAAC9C,OAAO,CAAC,IAAI,IAAK,EAAE;IAC1E;IACAwC,QAAQ,GAAGG,aAAa;EAC5B;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACIlF,QAAQ,CAAC;IAACiF,eAAe,EAAEF;EAAQ,CAAC,CAAC;EACrC,OAAOA,QAAQ;AACnB;;AAEA;AACA;AACA;AACA,SAASR,eAAeA,CAAC1B,CAAC,EAAC;EACvB,IAAIyC,WAAW,GAAGxF,UAAU,CAAC,CAAC,CAACyF,cAAc,GAAG,GAAG;EACnD,IAAIC,eAAe,GAAGF,WAAW,GAAG,GAAG,GAAGxF,UAAU,CAAC,CAAC,CAACyF,cAAc;EACrEvF,QAAQ,CAAC;IACLyF,cAAc,EAAE,MAAM;IACtB3D,OAAO,EAAE4D,IAAI,CAACC,KAAK,CAAC9C,CAAC,CAACJ,IAAI;EAC9B,CAAC,CAAC;EAEFf,YAAY,CAAC4C,IAAI,CAAC3C,MAAM,CAACiE,iBAAiB,CAAC;;EAE3C;EACA,IAAI9F,UAAU,CAAC,CAAC,CAAC+F,IAAI,IAAI/F,UAAU,CAAC,CAAC,CAAC+D,aAAa,IAAI,CAAC/D,UAAU,CAAC,CAAC,CAACqD,SAAS,EAAE;IAE5E;IACA;IACA,IAAI2C,WAAW,GAAG,oBAAoB,GAAGJ,IAAI,CAACC,KAAK,CAAC9C,CAAC,CAACJ,IAAI,CAAC,GAAG,UAAU;IACxEnC,kBAAkB,CAACwF,WAAW,EAAE,IAAI,CAAC;;IAErC;IACA;IACA,IAAGhG,UAAU,CAAC,CAAC,CAACyF,cAAc,EAAC;MAC3Bb,YAAY,CAAC3C,qBAAqB,CAAC;MACnCA,qBAAqB,GAAGgE,UAAU,CAAC,YAAY;QAC3CC,iBAAiB,CAACnD,CAAC,CAAC;;QAEpB;QACA7C,QAAQ,CAAC;UAACkE,SAAS,EAAE,CAACoB,WAAW,IAAInF,EAAE,CAACgE,IAAI,CAACC;QAAS,CAAC,CAAC;MAC5D,CAAC,EAAEtE,UAAU,CAAC,CAAC,CAACyF,cAAc,CAAC;IACnC,CAAC,MAAI;MACDS,iBAAiB,CAACnD,CAAC,CAAC;IACxB;EACJ;;EAEA;EAAA,KACI;IACA,IAAIoD,cAAc,GAAGzF,iBAAiB,CAACqC,CAAC,CAACJ,IAAI,CAAC;IAC9CtC,EAAE,CAACgE,IAAI,CAAC+B,GAAG,GAAG,CAACrD,CAAC,CAACJ,IAAI,GAAG,IAAI;IAE5BiC,YAAY,CAAC3C,qBAAqB,CAAC;IAEnCxB,QAAQ,CAAC0F,cAAc,CAAC1D,OAAO,EAAE0D,cAAc,CAACE,OAAO,EAAErG,UAAU,CAAC,CAAC,CAACyF,cAAc,EAAE,YAAU;MAC5F,IAAGzF,UAAU,CAAC,CAAC,CAACqD,SAAS,EAAC;QAEtB;AAChB;AACA;AACA;AACA;QAEgBpB,qBAAqB,GAAGgE,UAAU,CAAC,YAAU;UACzCC,iBAAiB,CAACnD,CAAC,CAAC;QACxB,CAAC,EAAC,EAAE,CAAC;MACT,CAAC,MAAI;QAEDmD,iBAAiB,CAACnD,CAAC,CAAC;;QAEpB;QACA7C,QAAQ,CAAC;UAACkE,SAAS,EAAE,CAACoB,WAAW,IAAInF,EAAE,CAACgE,IAAI,CAACC;QAAS,CAAC,CAAC;MAC5D;IACJ,CAAC,CAAC;EACN;;EAEA;EACA,IAAGkB,WAAW,EAAC;IACXZ,YAAY,CAAC1C,mBAAmB,CAAC;IACjCA,mBAAmB,GAAG+D,UAAU,CAAC,YAAU;MACvC/F,QAAQ,CAAC;QAACkE,SAAS,EAAE;MAAI,CAAC,CAAC;IAC/B,CAAC,EAAEsB,eAAe,CAAC;EACvB;AACJ;;AAEA;AACA;AACA;AACA,SAASQ,iBAAiBA,CAACnD,CAAC,EAAC;EACzB7C,QAAQ,CAAC;IAACoG,gBAAgB,EAAE;EAAK,CAAC,CAAC;EACnCzF,iCAAiC,CAACkC,CAAC,CAAC;;EAEpC;EACA,IAAGhD,KAAK,CAAC6D,UAAU,CAAC5D,UAAU,CAAC,CAAC,CAACuG,SAAS,CAAC,IAAI,CAACxD,CAAC,CAACU,eAAe,EAAC;IAC9D9B,YAAY,CAAC,WAAW,EAAEoB,CAAC,CAAC;EAChC;EAEA/B,WAAW,CAAC,CAAC;EAEb,IAAG,CAAC+B,CAAC,CAACU,eAAe,EAAC;IAClB1C,SAAS,CAACgC,CAAC,CAACN,OAAO,CAAC;EACxB;EAEA1C,KAAK,CAACkE,QAAQ,CAAClB,CAAC,CAACN,OAAO,EAAElB,UAAU,CAAC;EACrCxB,KAAK,CAACmE,WAAW,CAACnE,KAAK,CAACoE,QAAQ,CAACpB,CAAC,CAACN,OAAO,CAAC,EAAElB,UAAU,CAAC;EAExDL,cAAc,CAAC,CAAC;EAEhBhB,QAAQ,CAAC;IAACkE,SAAS,EAAE;EAAI,CAAC,CAAC;EAE3BxC,YAAY,CAAC4C,IAAI,CAAC3C,MAAM,CAACqE,iBAAiB,EAAEnD,CAAC,CAAC;EAE9C,IAAGhD,KAAK,CAAC6D,UAAU,CAACb,CAAC,CAACR,QAAQ,CAAC,EAAC;IAC5BQ,CAAC,CAACR,QAAQ,CAAC,CAAC;EAChB;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}